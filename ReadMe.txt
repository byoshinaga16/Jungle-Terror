Shortest Code: take line, north, shake tree, take stick, x boulders, take rock, x mud, take worm, combine stick with line, combine rod with worm, east, fish, west, north, cook fish, south, west, take handle, combine handle with rock, break door with axe, open door, north, give scientist cooked mullet, talk to scientist, wear goggles, south, unlock gate with rusty key, open gate, west, take mysterious stone, east, east, east, north, x wall, west, unlock hidden door with mysterious stone, open hidden door, north, enter code, east, take battery, take key card, north, unlock sample safe with key card, open sample safe, take x, take y, mix x with y, combine battery fluid with uncharged battery, west, fix submarine
	
When we were first assigned this project, my goal was to create an exciting, semi-complicated game, with little to no bugs or errors. I also wanted to base the setting of my game in some sort of tropical jungle. Looking at the final draft of my game, I would say that I am pretty pleased with how well my game accomplishes these goals. My game is pretty complicated considering it has 15 rooms, 91 objects/scenery, and several hidden doors. My puzzles are also a little challenging and not too easy. There is one noticeable bug in my game that I failed to get rid of. After the enemy is released, when the player enters commands, the text "you must supply a noun" will pop up afterwards. This doesn't affect the outcome of the command, but it may confuse the player a little. I was also happy with my setting of a tropical island. I got this tropical island idea from Far Cry 3 and I think this setting makes my game more interesting to play.
One time I got stuck was when I was trying to code the enemy's movement. I couldn't figure out how to make the enemy move a room every five turns. Even with peer and teacher suggestions, nothing seemed to work. Because I couldn't make the enemy move every five turns, I ended up changing the code entirely. Instead of creating a code where the enemy moves a room every five turns, I consulted the inform handbook and changed the enemy's movement to random. Now, the enemy has a 25% chance of moving every turn. In my opinion, this makes the game a little more interesting and difficult because the player doesn't know when the enemy will move. This forces the player to decide whether or not to take the risk of staying put.
The three puzzles in my game are feeding the scientist, fixing a submarine, and maneuvering around the map without running into the enemy. The first puzzle, feeding the scientist, requires the player to gather items, create a fishing rod, and catching then cooking a fish. One of items for the fishing rod requires the player to shake a tree in order to retrieve it. The player also has to find the pond to fish in, and find the place to cook the fish. Once the player has the cooked fish, he must make an axe to unlock the hut door. After that, he can finally give the fish to the scientist who is in the hut. The second puzzle is fixing a submarine. All the player has to do for this puzzle is create a charged battery and combine it with the broken submarine. In order to create the charged battery, the player must mix the correct combination of liquids (found in a sample safe) to create battery fluid, which can then be added to the broken battery. If the wrong combination of liquids is mixed though, the player dies and the game ends. The correct combination of liquids can be found by examining the broken battery. The third puzzle is evading the enemy. Once the enemy is released (after opening a gate), the player must safely make his or her way to the safety of the secret lab. Maneuvering around the map can be difficult if the enemy is released too early in the game.
While coding my game, I thought hard about what the player might type while playing my game. Therefore, I added in a great amount of synonyms for words, and instead statements for actions. My code ended up being around 8000 words long. Synonyms and instead statements contribute a big amount to this word count. I tried to make sure that everything the player types will be recognized. I also tried to eliminate as many default responses I could in my game. For example, when combining objects, I removed the default response, and created my own dialogue. This makes the game more interesting and easier to follow. While coding, I tried to add a little humor and voice. I did this because I wanted the player to enjoy playing my game. Nobody enjoys playing a boring game with plain responses. I also spent a lot of time putting tiny details into my game. One of these tiny details includes changing the description of the player when wearing goggles. In my opinion, tiny details like these make the game that much more fun to play. 
For beta testing, I had Ty Suthard and Cameron Haseyama test my game. During testing, I noticed many mistakes and flaws in my game. I ended up with two full pages of revisions. Without beta testing and testers, I probably wouldn't have noticed those errors in my game. Ty's and Cameron''s feedback definitely made my game much better. If it wasn't for them, my final game might be impossible for the player to win because I, as the creator of the game, know how to play while others don't. Because of their feedback, I was also able to change and add many descriptions that didn't make sense or were missing. 
I beta tested Ty Suthard's game. As a beta tester, I was able to give a lot of feedback. I pointed out areas that were too complicated, areas that were too confusing, and missing descriptions. Hopefully I was able to help Ty improve and polish game. 
In my game, I am most proud of my enemy: the creature. I am most proud of this NPC because I created him all by myself. This NPC was very hard to create mostly because of his movement and entry in the game. There wasn't anything I could copy straight off of another source code or the inform handbook. I had to take fragments of code from multiple resources and alter them myself in order to create this NPC. This took a lot of thinking and problem solving, but in the end, everything worked out and I wasn't disappointed.
Next time, I would probably try to spend my time more wisely. I had a lot of free time that I could've spent working on this project instead of doing other things. If I spent my time more wisely, I wouldn't have to rush to finish my project. When I rush, I tend to do a relatively poor job compared to when I spread out my work time. 
